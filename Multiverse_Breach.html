<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>DC vs Marvel: Mobile Run</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Courier New', Courier, monospace; 
            touch-action: none; /* Disables browser scrolling on swipe */
        }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            z-index: 10;
            pointer-events: none; /* Let touches pass through to game */
        }
        #score-board { font-size: 24px; font-weight: bold; text-shadow: 2px 2px 0 #000; }
        #instructions { font-size: 14px; opacity: 0.9; margin-top: 5px; text-shadow: 1px 1px 0 #000; }
        
        /* Game Over Screen */
        #game-over {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border: 2px solid white;
            border-radius: 10px;
            z-index: 20;
            width: 80%;
        }
        
        /* Buttons */
        #btn-restart {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 18px;
            cursor: pointer;
            background: #ff0000;
            color: white;
            border: none;
            border-radius: 5px;
        }
        
        #hero-select {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 15px;
            z-index: 10;
        }
        button.hero-btn {
            padding: 15px 20px;
            font-weight: bold;
            border: 2px solid white;
            border-radius: 5px;
            font-size: 16px;
        }
        .btn-marvel { background: #E23636; color: white; }
        .btn-dc { background: #222; color: white; }
    </style>
</head>
<body>

    <div id="ui-container">
        <div id="score-board">SCORE: 0</div>
        <div id="instructions">SWIPE to Move & Jump</div>
    </div>

    <div id="hero-select">
        <button class="hero-btn btn-marvel" onclick="setTheme('MARVEL')">IRON MAN</button>
        <button class="hero-btn btn-dc" onclick="setTheme('DC')">BATMAN</button>
    </div>

    <div id="game-over">
        <h1>GAME OVER</h1>
        <p id="final-score">Score: 0</p>
        <button id="btn-restart" onclick="resetGame()">TAP TO RESTART</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- GAME CONFIGURATION ---
        const LANES = [-3, 0, 3];
        let currentLane = 1; 
        let gameSpeed = 0.4; // Slightly slower for mobile start
        let score = 0;
        let isGameOver = false;
        let isJumping = false;
        let jumpVelocity = 0;
        const GRAVITY = 0.025;
        let gameStarted = false;

        // Theme Settings
        let currentTheme = 'MARVEL';
        const THEMES = {
            MARVEL: { player: 0xff0000, secondary: 0xffd700, sky: 0x87CEEB, obs: 0x00ff00 },
            DC: { player: 0x111111, secondary: 0x555555, sky: 0x1a1a2e, obs: 0xccff00 } 
        };

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(THEMES[currentTheme].sky, 10, 50);
        scene.background = new THREE.Color(THEMES[currentTheme].sky);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 4, 9); // Higher camera for mobile visibility
        camera.lookAt(0, 1, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        scene.add(dirLight);

        // --- OBJECTS ---
        
        // Ground
        const groundGeo = new THREE.PlaneGeometry(50, 200);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.z = -50;
        ground.receiveShadow = true;
        scene.add(ground);

        // Player
        const playerGeo = new THREE.BoxGeometry(1, 1.5, 1);
        const playerMat = new THREE.MeshStandardMaterial({ color: THEMES[currentTheme].player });
        const player = new THREE.Mesh(playerGeo, playerMat);
        player.position.y = 0.75;
        player.castShadow = true;
        scene.add(player);

        // Detail (Arc Reactor/Symbol)
        const decoGeo = new THREE.BoxGeometry(0.4, 0.4, 0.2);
        const decoMat = new THREE.MeshStandardMaterial({ color: THEMES[currentTheme].secondary, emissive: 0x222222 });
        const deco = new THREE.Mesh(decoGeo, decoMat);
        deco.position.set(0, 0.5, 0.5); 
        player.add(deco);

        let obstacles = [];
        let particles = []; 

        // --- TOUCH INPUT HANDLING ---
        let touchStartX = 0;
        let touchStartY = 0;

        document.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, false);

        document.addEventListener('touchend', (e) => {
            if (isGameOver) return;
            if (!gameStarted) { gameStarted = true; return; }

            const touchEndX = e.changedTouches[0].screenX;
            const touchEndY = e.changedTouches[0].screenY;
            handleSwipe(touchStartX, touchEndX, touchStartY, touchEndY);
        }, false);

        function handleSwipe(startX, endX, startY, endY) {
            const diffX = endX - startX;
            const diffY = endY - startY;
            const threshold = 30; // Min swipe distance

            if (Math.abs(diffX) > Math.abs(diffY)) {
                // Horizontal Swipe
                if (Math.abs(diffX) > threshold) {
                    if (diffX > 0) { // Right
                        if (currentLane < 2) changeLane(1);
                    } else { // Left
                        if (currentLane > 0) changeLane(-1);
                    }
                }
            } else {
                // Vertical Swipe
                if (Math.abs(diffY) > threshold) {
                    if (diffY < 0) { // Swipe UP (Y coords decrease going up)
                         if (!isJumping) {
                            isJumping = true;
                            jumpVelocity = 0.45;
                        }
                    }
                }
            }
        }

        // Keep Keyboard for testing
        document.addEventListener('keydown', (e) => {
            if (isGameOver) return;
            gameStarted = true;
            if (e.key === 'ArrowLeft') { if(currentLane > 0) changeLane(-1); }
            if (e.key === 'ArrowRight') { if(currentLane < 2) changeLane(1); }
            if (e.key === ' ' || e.key === 'ArrowUp') { if(!isJumping) { isJumping = true; jumpVelocity = 0.45; } }
        });

        function changeLane(dir) {
            currentLane += dir;
            player.rotation.z = -dir * 0.2;
            setTimeout(() => player.rotation.z = 0, 200);
        }

        // --- GAME LOGIC ---

        function spawnObstacle() {
            if (isGameOver || !gameStarted) return;
            
            const laneIndex = Math.floor(Math.random() * 3);
            const obsGeo = new THREE.BoxGeometry(1, 1, 1);
            const obsMat = new THREE.MeshStandardMaterial({ color: THEMES[currentTheme].obs }); 
            const obstacle = new THREE.Mesh(obsGeo, obsMat);
            
            obstacle.position.set(LANES[laneIndex], 0.5, -60);
            obstacle.castShadow = true;
            
            scene.add(obstacle);
            obstacles.push(obstacle);
        }

        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < 80; i++) {
                vertices.push((Math.random() - 0.5) * 40);
                vertices.push((Math.random()) * 20);
                vertices.push((Math.random() - 0.5) * 100 - 50);
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const material = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
            const stars = new THREE.Points(geometry, material);
            scene.add(stars);
            particles.push(stars);
        }
        createParticles();

        function setTheme(themeName) {
            currentTheme = themeName;
            const t = THEMES[themeName];
            player.material.color.setHex(t.player);
            deco.material.color.setHex(t.secondary);
            scene.background.setHex(t.sky);
            scene.fog.color.setHex(t.sky);
            document.getElementById('hero-select').style.display = 'none'; // Hide buttons after picking
            gameStarted = true;
        }

        function gameOver() {
            isGameOver = true;
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('final-score').innerText = "Score: " + Math.floor(score);
            document.getElementById('hero-select').style.display = 'none';
        }

        function resetGame() {
            isGameOver = false;
            score = 0;
            gameSpeed = 0.4;
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('score-board').innerText = "SCORE: 0";
            
            obstacles.forEach(obs => scene.remove(obs));
            obstacles = [];
            
            player.position.set(0, 0.75, 0);
            currentLane = 1;
        }

        // --- ANIMATION LOOP ---
        let frameCount = 0;

        function animate() {
            requestAnimationFrame(animate);

            if (isGameOver) return;
            if (!gameStarted) return;

            // Player Movement
            const targetX = LANES[currentLane];
            player.position.x += (targetX - player.position.x) * 0.2; // Smoother lerp for mobile

            if (isJumping) {
                player.position.y += jumpVelocity;
                jumpVelocity -= GRAVITY;
                if (player.position.y <= 0.75) {
                    player.position.y = 0.75;
                    isJumping = false;
                }
            }

            // Move Obstacles
            frameCount++;
            if (frameCount % Math.max(25, (60 - Math.floor(score/100))) === 0) {
                spawnObstacle();
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obs = obstacles[i];
                obs.position.z += gameSpeed;

                // Collision
                if (obs.position.z > -1 && obs.position.z < 1) {
                    if (Math.abs(obs.position.x - player.position.x) < 0.6) {
                         if (player.position.y < 1.4) {
                             gameOver();
                         }
                    }
                }

                if (obs.position.z > 5) {
                    scene.remove(obs);
                    obstacles.splice(i, 1);
                    score += 10;
                    document.getElementById('score-board').innerText = "SCORE: " + score;
                    gameSpeed += 0.0005;
                }
            }

            particles.forEach(p => {
                p.position.z += gameSpeed / 1.5;
                if(p.position.z > 20) p.position.z = -50;
            });

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
